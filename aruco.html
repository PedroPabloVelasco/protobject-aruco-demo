<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Aruco Order</title>
  </head>
  <body>
    <h2>Vista previa de la cámara</h2>
    <div id="preview" style="width:426px;height:240px;border:1px solid #333;border-radius:10px;"></div>

    <script src="https://app.protobject.com/framework/p.js"></script>
    <script src="config.js"></script>
    <script>
      // ====== CONFIG ======
      const PC_PAGE = "index.html";
  const IDS = [200, 1, 100];       // IDs objetivo
  const SEND_INTERVAL_MS = 250;    // reintento de envío
  const PERSIST_MS = 400;          // ventana para mantener marcador tras perderlo
  const MIN_SIZE = 0;              // filtra marcadores demasiado pequeños (area)
  const ALPHA_Y = 0.4;             // suavizado exponencial de Y
  const LOG_DEBUG = true;

      // ====== ESTADO DE ENVÍO (cola simple) ======
      let lastOrder = null;
      let lastSignature = "";
      let sendTimer = null;

      // Reintenta enviar lastOrder periódicamente (hasta que el canal esté listo)
      function startRetrySender() {
        if (sendTimer) return;
        sendTimer = setInterval(() => {
          if (!lastOrder || !lastOrder.length) return;
          try {
            Protobject.Core.send(lastOrder).to(PC_PAGE);
          } catch (_) {
            // si falla, seguimos reintentando; p.js mostrará el warning hasta que conecte
          }
        }, SEND_INTERVAL_MS);
      }

      // ====== ARRANQUE CUANDO EL DOM ESTÁ LISTO ======
      window.addEventListener("DOMContentLoaded", () => {
        // 1) Inicia ArUco (la forma que tenías antes)
        Protobject.Aruco.start(30, 0);

        // 2) Muestra preview dentro del div #preview (como tu base)
        Protobject.Aruco.showPreview({
          top: 0,
          left: 0,
          width: 1280/3,
          height: 720/3,
          element: document.getElementById("preview")
        });

        // 3) Lógica: ordena por Y descendente y manda array de IDs a index.html
        // Almacén persistente { id -> { y, ts } }
        const store = new Map();

        Protobject.Aruco.onData((data) => {
          const now = Date.now();
            // Actualizar mediciones
            IDS.forEach(id => {
              const d = data[id];
              if (d && d.position && typeof d.position.y === 'number' && (!MIN_SIZE || d.size >= MIN_SIZE)) {
                const prev = store.get(id);
                const newY = prev ? (ALPHA_Y * d.position.y + (1-ALPHA_Y) * prev.y) : d.position.y;
                store.set(id, { y: newY, ts: now });
              }
            });
            // Expirar antiguos
            for (const [id, rec] of Array.from(store.entries())) {
              if (now - rec.ts > PERSIST_MS) store.delete(id);
            }
            // Construir orden por Y descendente
            const active = Array.from(store.entries()).map(([id, v]) => ({ id, y: v.y }));
            active.sort((a,b)=> b.y - a.y);
            const order = active.map(m=>parseInt(m.id));
            if (LOG_DEBUG) console.log('rawIds', Object.keys(data), 'active', active, 'order', order);

            const sig = JSON.stringify(order);
            if (sig !== lastSignature) {
              lastSignature = sig;
              lastOrder = order;
              try { Protobject.Core.send(order).to(PC_PAGE); } catch(_) {}
            }
        });

        // 4) Arranca el reintento de envío
        startRetrySender();

        console.log("Aruco iniciado (cam id 0) y preview en #preview");
      });

      // Registrar un receptor (aunque no lo uses) ayuda a evitar el log de "no callback registered"
      Protobject.Core.onReceived(() => {});
    </script>

    <style>
      #ProtobjectPlusButton { width: 80px !important; }
      #ProtobjectPlusButton::after { content: " Connect"; }
    </style>
  </body>
</html>
